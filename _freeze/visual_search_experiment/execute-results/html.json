{
  "hash": "121f1be8eaa60bee94b6d6209ce492c5",
  "result": {
    "markdown": "---\ntitle: Visual Search Report\nauthor: DÃ¡vid Kubek\ndate: last-modified\ndate-format: long\nbibliography: references.bib\nformat:\n  html:\n    toc: true\n    theme: custom.scss\n    code-fold: true\n    code-line-numbers: true\n  pdf:\n    echo: false\nexecute:\n  cache: true\n---\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport warnings\nwarnings.simplefilter(action='ignore', category=FutureWarning)\n\nimport numpy as np\nimport seaborn as sns\nimport statsmodels.api as sm\nimport statsmodels.formula.api as smf\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nfrom pathlib import Path\n\n# classes for special types\nfrom pandas.api.types import CategoricalDtype\n\n# Apply the default theme\nsns.set_theme(style=\"ticks\")\n\n# Set default precision for displaying numbers\npd.set_option(\"display.precision\", 2)#| \n```\n:::\n\n\n# Introduction\n\nThe visual search experiment is a psychology experiment that is used to study\nhow the human visual system processes and searches for specific stimuli in a\nvisual scene. The experiment typically involves presenting participants with a\nvisual display, such as a picture or a computer screen, that contains a number\nof objects or stimuli. The participants are then asked to search for a specific\ntarget stimulus, such as a pink line, among the other stimuli in the display.\n\nDuring the experiment, the researcher may manipulate various factors, such as\nthe number of stimuli in the display, the similarity of the stimuli to the\ntarget, or the location of the target within the display. These manipulations\nallow the researcher to study how different factors affect the speed and\naccuracy of the participant's search for the target stimulus.\n\nOne of the most widely used manipulation in visual search experiment is the set\nsize, which is the number of stimuli in the display. The experimenter increases\nthe set size and observe how it affects the reaction time of the participants. \n\nAnother manipulation that is often used in visual search experiments is the\nsimilarity of the stimuli to the target. This can include manipulating the\ncolor, shape, or size of the stimuli to make them more or less similar to the\ntarget. The experimenter can observe how these manipulations affect the speed\nand accuracy of the participant's search for the target.\n\nThe visual search experiment is a powerful tool for studying the human visual\nsystem because it allows researchers to study how the brain processes and\nsearches for specific stimuli in a visual scene. \n\nOverall, visual search experiment is a widely used method in cognitive\npsychology to study how visual perception and attention work. It provides\nresearchers with a tool to investigate fundamental question about how we\nperceive and process visual information in the world around us.\n\n[@Wolfe:2008]\n\n# Experiment Setup\n\nWe will study how the reaction time changes as set size increases under\ndifferent circumstances. Specifically, the effects of set size, homogeneity\n(feature vs. conjunction) and target presence on reaction time will be examined.\nA total of N=3 participants will be recruited for the study. We then fit a\nlinear regression model predicting the reaction time based on the set size,\nsearch type and target presence. We will be interested in the coefficient in the\nlinear model corresponding to set size. We can think of the slope as giving us a\nmeasure of how much does the reaction time increase, if we increase the set size\nby 1.  This will be our measure of efficiency.\n\nThe experiment will consist of 300 trials, in which participants will be\npresented with an image containing a set of lines with different orientations\n(either ``/`` or ``\\``). The participants will be instructed to search for a\npink line with an orientation of ``/`` and indicate whether it is present or\nabsent. The trials will vary in set size (10, 20, 30, or 40) and search type\n(feature or conjunction). In _feature search_, the image will contain only lines\nof a single color (lines with orientation ``\\`` act as distractors), while in\n_conjunction search_, the image will contain a mixture of blue and pink lines\n(blue lines and pink lines with orientation ``\\`` act as distractors).\nParticipants will be provided with feedback on the accuracy of their responses\nand encouraged to respond as quickly as possible. The estimated duration of the\nexperiment is approximately 15-20 minutes.\n\nThe participants consisted of students in age range 20-25 years old. Both\ngenders were represented. The participants were seated in front of a 14-inch\nmonitor with 1920x1080 resolution and instructed to make themselves comfortable.\nNo training trials were conducted prior to the experiment. No participant needed\nto take a break during the experiment.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# Load data\ndata_path = Path('data/')\n\ndef load_file(filepath : Path) -> pd.DataFrame:\n    participant_id = filepath.stem\n    df = pd.read_csv(filepath)\n    \n    # Delete rows that do not contain response data\n    df = df[df.trial_type == 'canvas-keyboard-response']\n    \n    df['participant'] = participant_id\n    df = df.rename(\n      {\"setSize\": \"set_size\"},\n      axis=1\n      )\n    df = df[\n      ['participant', 'present', 'set_size', 'conjuction','correct' , 'rt']\n      ]\n    df = df.astype(\n      {\n        \"participant\": int,\n        \"present\": bool,\n        'set_size': int, \n        'conjuction': bool,\n        'correct': bool,\n        'rt': int\n      }\n    )\n    df = df.reset_index(drop=True)\n    \n    return df\n\n\ndf_all = pd.concat(\n    load_file(file) for file in data_path.glob(\"*.csv\")\n  )\\\n  .reset_index(drop=True)\ndf_all = df_all[df_all['participant'] > 0]\n```\n:::\n\n\n::: {.cell tbl-cap='Sample of the input data.' execution_count=4}\n``` {.python .cell-code}\ndf_all.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>participant</th>\n      <th>present</th>\n      <th>set_size</th>\n      <th>conjuction</th>\n      <th>correct</th>\n      <th>rt</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>True</td>\n      <td>30</td>\n      <td>True</td>\n      <td>True</td>\n      <td>2975</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1</td>\n      <td>True</td>\n      <td>20</td>\n      <td>True</td>\n      <td>True</td>\n      <td>713</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1</td>\n      <td>False</td>\n      <td>20</td>\n      <td>True</td>\n      <td>True</td>\n      <td>1641</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1</td>\n      <td>False</td>\n      <td>30</td>\n      <td>False</td>\n      <td>True</td>\n      <td>2071</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>1</td>\n      <td>False</td>\n      <td>10</td>\n      <td>True</td>\n      <td>True</td>\n      <td>1064</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Remove incorrect responses\ndf_correct = df_all[df_all.correct]\n```\n:::\n\n\n# Results\n\nFirstly, in @tbl-accuracy we report the accuracy (percentage of errors for each\nparticipant). Additionally @fig-accuracy we report the accuracy of the\nparticipants on different search types as well as set sizes. We remove the error\ntrials for the subsequent analysis.\n\n::: {#tbl-accuracy .cell tbl-cap='Participant accuracy.' execution_count=6}\n``` {.python .cell-code}\n# Report accuracy\nhlp = df_all.groupby('participant')\\\n  .agg(accuracy=('correct', 'mean'))\\\n  .round(decimals=3)\\\n  .reset_index()\nhlp = hlp.rename(\n  {\n    \"participant\": \"Participant\",\n    \"accuracy\": \"Accuracy\",\n  },\n  axis='columns'\n)\n\nhlp\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Participant</th>\n      <th>Accuracy</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>0.94</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>0.98</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n      <td>0.94</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nhlp = df_all.groupby(['participant','set_size', 'conjuction'])\\\n  .agg(\n    Correct=('correct', 'mean'),\n    Incorrect=('correct', lambda _: 1 - _.mean())\n  )\\\n  .reset_index()\nhlp = pd.melt(\n  hlp,\n  id_vars=['participant','set_size', 'conjuction'],\n  var_name='is_correct', value_name='perc'\n)\nhlp['participant'] = hlp['participant'].astype(str)\nhlp['set_size'] = hlp['set_size'].astype(str)\nhlp['conjuction'] = hlp['conjuction'].map(\n  lambda _: 'Conjunction' if _ else 'Feature'\n  )\nhlp = hlp.sort_values(['participant', 'set_size'])\n\ng = sns.displot(\n    data=hlp,\n    x='set_size',\n    hue='is_correct',\n    multiple='stack',\n    col='participant',\n    row='conjuction',\n    weights='perc',\n    palette={'Correct': 'g', 'Incorrect': 'r'},\n    hue_order=['Incorrect', 'Correct'],\n    facet_kws=dict(margin_titles=True),\n)\ng.set_titles(col_template=\"Participant {col_name}\", row_template=\"{row_name}\")\ng.set_ylabels(\"Accuracy\")\ng.set_xlabels(\"Set size\")\ng.legend.set_title(\"Answer\")\ng.fig.subplots_adjust(top=0.9)\ng.fig.suptitle(\n  \"Accuracy for each participant split by set size and homogeneity.\"\n  );\n```\n\n::: {.cell-output .cell-output-display}\n![Accuracy of of each participant (column) split by homogenity (row).](visual_search_experiment_files/figure-html/fig-accuracy-output-1.png){#fig-accuracy width=1553 height=941}\n:::\n:::\n\n\nIn @fig-rt we report the distribution of reaction times split by set size for\neach participant.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nhlp = df_correct[[\"participant\", \"set_size\", \"rt\"]].copy()\n\n# Treat set size as categorical data\nhlp[\"set_size\"] = hlp[\"set_size\"].astype(str)\n\ng = sns.catplot(\n  data=hlp, \n  y=\"set_size\", x=\"rt\",\n  hue='participant',\n  kind='box',\n  aspect=2,\n  )\ng.ax.xaxis.grid(True)\ng.set_xlabels(\"Reaction time (ms)\")\ng.set_ylabels(\"Set size\")\ng.set(title=\"Reaction times of participants split by set size\");\n```\n\n::: {.cell-output .cell-output-display}\n![Reaction times divided by set size.](visual_search_experiment_files/figure-html/fig-rt-output-1.png){#fig-rt width=1046 height=484}\n:::\n:::\n\n\nNext, we focus our attention on predicting the reaction times based on set size.\nWe are interested in how the performance changes if we change the homogeneity\n(feature/conjunction) and target presence. In @tbl-results we report the set\nsize effect (search slope) for each case and participant with the 95% confidence\ninterval.\n\nIt is noteworthy that the slope for feature search is consistently lower\ncompared to conjunction search (when the target is present). This trend is also\nobserved for target absent trials in both feature and conjunction searches.\nLastly, the absence of the target leads to an increase in the search slope,\nregardless of the search type.\n\nThese observations are also depicted in the @fig-slope.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# Fit a linear regression model predicting the reaction time based on set size.\n# Consider cases with different homogeneity and whether the target was present\n# or not and report the slope of the coefficient for reaction time and 95%\n# confidence interval. This time consider\n\nparticipants = df_correct.participant.unique()\ndf_result = pd.DataFrame(\n  columns=[\n    \"participant\", \"conjunction\", \"present\", \"set_size_slope\", \"ci_l\", \"ci_u\", \n    \"r2\",\n    ]\n  )\nfor participant in participants:\n    for is_conjunction in [True, False]:\n        for target_present in [True, False]:\n            hlp = df_correct[\n                (df_correct.participant == participant) &\n                (df_correct.conjuction == is_conjunction) &\n                (df_correct.present == target_present)\n            ]\n            model = smf.ols('rt ~ set_size', data=hlp)\n            result = model.fit()\n\n            ci = result.conf_int(alpha=0.05).loc[\"set_size\"]\n            tmp = [\n                participant,\n                int(is_conjunction),\n                int(target_present),\n                result.params[\"set_size\"],\n                ci[0],\n                ci[1],\n                result.rsquared\n            ]\n            df_result = pd.concat(\n              [df_result, pd.DataFrame([tmp], columns=df_result.columns)],\n              ignore_index=True\n              )\n\ndf_result = df_result.assign(\n    yerr=lambda _: np.abs(_['set_size_slope'] - _['ci_l']),\n)\n```\n:::\n\n\n::: {#tbl-results .cell tbl-cap='Search slope with 95% confidence intervals.' execution_count=10}\n``` {.python .cell-code}\n# Print pretty table\nhlp = df_result[\n    ['participant', 'conjunction', 'present', 'set_size_slope', 'ci_l','ci_u']\n].copy()\nhlp['conjunction'] = hlp['conjunction'].map(\n  lambda _: 'Conjunction' if _ == 1 else 'Feature'\n  )\nhlp['present'] = hlp['present'].map(lambda _: 'Y' if _ == 1 else 'F')\nhlp = hlp.rename(\n    {\n        \"participant\": \"Participant\",\n        \"conjunction\": \"Homogeneity\",\n        \"present\": \"Target Present\",\n        \"set_size_slope\": \"Search Slope\",\n        \"ci_l\": \"95% CI Lower\",\n        \"ci_u\": \"95% CI Upper\",\n    },\n    axis='columns'\n)\nhlp.reset_index(drop=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Participant</th>\n      <th>Homogeneity</th>\n      <th>Target Present</th>\n      <th>Search Slope</th>\n      <th>95% CI Lower</th>\n      <th>95% CI Upper</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>Conjunction</td>\n      <td>Y</td>\n      <td>8.20</td>\n      <td>0.13</td>\n      <td>16.27</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1</td>\n      <td>Conjunction</td>\n      <td>F</td>\n      <td>9.14</td>\n      <td>2.22</td>\n      <td>16.07</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1</td>\n      <td>Feature</td>\n      <td>Y</td>\n      <td>-2.18</td>\n      <td>-5.95</td>\n      <td>1.59</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1</td>\n      <td>Feature</td>\n      <td>F</td>\n      <td>6.12</td>\n      <td>-0.05</td>\n      <td>12.29</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>3</td>\n      <td>Conjunction</td>\n      <td>Y</td>\n      <td>17.91</td>\n      <td>9.77</td>\n      <td>26.06</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>3</td>\n      <td>Conjunction</td>\n      <td>F</td>\n      <td>17.77</td>\n      <td>7.89</td>\n      <td>27.66</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>3</td>\n      <td>Feature</td>\n      <td>Y</td>\n      <td>4.40</td>\n      <td>-2.74</td>\n      <td>11.53</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>3</td>\n      <td>Feature</td>\n      <td>F</td>\n      <td>13.69</td>\n      <td>6.49</td>\n      <td>20.90</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>2</td>\n      <td>Conjunction</td>\n      <td>Y</td>\n      <td>4.78</td>\n      <td>-1.24</td>\n      <td>10.79</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>2</td>\n      <td>Conjunction</td>\n      <td>F</td>\n      <td>24.34</td>\n      <td>17.54</td>\n      <td>31.14</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>2</td>\n      <td>Feature</td>\n      <td>Y</td>\n      <td>-1.59</td>\n      <td>-10.00</td>\n      <td>6.83</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>2</td>\n      <td>Feature</td>\n      <td>F</td>\n      <td>10.69</td>\n      <td>2.14</td>\n      <td>19.23</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# Plot search slope for target present absent and feature or conjunction\nfrom matplotlib.lines import Line2D\n\ncolors = ['C0', 'C1', 'C2']\nmarkers = []\nlabels = []\nfor participant, color in enumerate(colors):\n    for target_present, shape in [('present', 'o'), ('absent', 's')]:\n        marker = Line2D(\n            [], [], color=color, marker=shape, linestyle='none', markersize=5\n        )\n        markers.append(marker)\n        labels.append(\n          'Participant ' + str(participant + 1) + ', ' + target_present\n          )\n    \n    \nmin_y = np.floor(df_result.ci_l.min()) - 1\nmax_y = np.ceil(df_result.ci_u.max()) + 1\n\nfig, axes = plt.subplots(1, 2, figsize=(16, 5))\n\ndata = [\n        (\"Feature\", df_result[df_result.conjunction == 0]),\n        (\"Conjunction\", df_result[df_result.conjunction == 1])\n]\n\ndelta = 0.1\nfor i, (title, df) in enumerate(data):\n    for target_present in [True, False]:\n        hlp = df[df.present == target_present]\n        \n        axes[i].scatter(\n            hlp.participant + (-delta if target_present else delta),\n            hlp.set_size_slope,\n            color=colors,\n        )\n\n        for color, participant in zip(colors, hlp.participant):\n            row = hlp[hlp.participant == participant]\n            \n            axes[i].errorbar(\n                participant + (-delta if target_present else delta),\n                row.set_size_slope,\n                yerr=row.yerr,\n                ls='none',\n                marker='o' if target_present else 's',\n                ecolor=color,\n                c=color,\n            )\n\n    # Hide the right and top spines\n    axes[i].spines[['right', 'top']].set_visible(False)\n    axes[i].grid(which='major', axis='y', linestyle='-')\n    axes[i].set_xticks(hlp.participant.astype(float))\n    axes[i].set(title=title, xlabel='Participant', ylabel='Slope')\n    axes[i].set_ylim(bottom=min_y, top=max_y)\n\nfig.suptitle(\"Search slope with 95% confidence intervals\")\nfig.tight_layout()\nfig.subplots_adjust(right=0.85)\nfig.legend(\n    markers,\n    labels,\n    loc=7,\n);\n```\n\n::: {.cell-output .cell-output-display}\n![Search slope with 95% confidence intervals. The left figure contains the values for feature search, the right for conjunction search. Two values for each participant are shown. One for target present (circle) and one for target absent (square).](visual_search_experiment_files/figure-html/fig-slope-output-1.png){#fig-slope width=1531 height=472}\n:::\n:::\n\n\n# Conclusion\n\nWe now address the observed results.\n\nFirst, we address the variations in slopes for different search types in the\npresence of the target. The visual salience of the target in feature search\nleads to it immediately capturing our attention as it drastically differs from\nits surroundings. Conversely, the presence of distractors results in several\nsimilar items attracting our attention, which necessitates the examination of\nmore items, thereby leading to an increase in reaction time, which agrees with\nour observations.\n\nNext we address the difference in slope for the target absent trials.  In target\npresent trials, it is generally necessary to examine roughly half of the set\nsize items until the target is found.  However, in the absence of the target,\nthe participant must spend more time examining the objects in search of a\ntarget, which results in an increase in reaction time, which is consistent with\nour observations.\n\n",
    "supporting": [
      "visual_search_experiment_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}